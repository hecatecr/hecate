# Task ID: 13
# Title: Implement Lexer Rule Types
# Status: pending
# Dependencies: 12
# Priority: medium
# Description: Create rule structures for pattern matching with regex, skip behavior, and priority
# Details:
Create src/hecate/lex/rule.cr:
```crystal
module Hecate::Lex
  struct Rule(T)
    getter kind : T
    getter pattern : Regex
    getter skip : Bool
    getter priority : Int32
    getter error_handler : Symbol?
    
    def initialize(@kind : T, pattern : String | Regex, 
                   @skip = false, @priority = 0, @error_handler = nil)
      @pattern = pattern.is_a?(String) ? Regex.new(pattern) : pattern
    end
    
    def match_at(text : String, pos : Int32) : Regex::MatchData?
      # Anchor pattern at position for efficient matching
      anchored = Regex.new("\\A(?:#{@pattern.source})")
      anchored.match(text[pos..])
    end
  end
  
  class RuleSet(T)
    getter rules : Array(Rule(T))
    getter error_handlers : Hash(Symbol, ErrorHandler)
    
    def initialize
      @rules = [] of Rule(T)
      @error_handlers = {} of Symbol => ErrorHandler
    end
    
    def add_rule(rule : Rule(T))
      @rules << rule
      # Sort by priority (higher first) for longest-match-wins
      @rules.sort_by! { |r| -r.priority }
    end
  end
end
```

# Test Strategy:
Test pattern matching at specific positions, priority ordering, regex compilation and caching

# Subtasks:
## 1. Create Rule struct with basic fields [pending]
### Dependencies: None
### Description: Implement the Rule struct with all required fields and basic initialization
### Details:
Create the Rule struct in src/hecate/lex/rule.cr with fields for kind (generic type T), pattern (Regex), skip (Bool), priority (Int32), and error_handler (Symbol?). Implement the initializer that accepts either String or Regex for pattern and converts String to Regex if needed.

## 2. Implement match_at method for Rule [pending]
### Dependencies: 13.1
### Description: Add the match_at method to Rule struct for pattern matching at specific positions
### Details:
Implement match_at method that takes text and position, creates an anchored regex using \A to match at the exact position, and returns the MatchData if found. Ensure efficient substring handling using text[pos..] to avoid unnecessary string copies.

## 3. Create RuleSet class structure [pending]
### Dependencies: 13.1
### Description: Implement the RuleSet class to manage collections of rules and error handlers
### Details:
Create RuleSet class with generic type T, containing an array of Rule(T) and a hash of Symbol to ErrorHandler. Initialize empty collections in the constructor. This will serve as the container for all lexer rules.

## 4. Implement add_rule with priority sorting [pending]
### Dependencies: 13.3
### Description: Add the add_rule method to RuleSet that maintains rules sorted by priority
### Details:
Implement add_rule method that appends a rule to the rules array and immediately re-sorts the array by priority in descending order (higher priority first). This ensures longest-match-wins behavior when multiple patterns could match at the same position.

## 5. Add error handler management to RuleSet [pending]
### Dependencies: 13.3
### Description: Implement methods to register and retrieve error handlers in RuleSet
### Details:
Add methods to register error handlers by symbol and retrieve them when needed. This allows rules to reference error handlers by symbol for custom error recovery strategies. Consider adding register_error_handler and get_error_handler methods.

