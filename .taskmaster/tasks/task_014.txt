# Task ID: 14
# Title: Build Lexer Definition DSL
# Status: pending
# Dependencies: 13
# Priority: high
# Description: Create macro-based DSL for declarative lexer definitions with compile-time token enum generation
# Details:
Create src/hecate/lex/dsl.cr:
```crystal
module Hecate::Lex
  macro define(&block)
    # Generate token kind enum
    enum TokenKind
      EOF
      {% for rule in block.body.select { |n| n.is_a?(Call) && n.name == "token" } %}
        {{rule.args[0].id}}
      {% end %}
    end
    
    # Generate lexer class
    class GeneratedLexer
      @rule_set = RuleSet(TokenKind).new
      
      def initialize
        # Add EOF rule
        @rule_set.add_rule(Rule.new(TokenKind::EOF, /\z/, priority: -1000))
        
        # Process DSL block
        {{block.body}}
      end
      
      macro token(kind, pattern, skip = false, priority = 0, on_error = nil)
        @rule_set.add_rule(Rule.new(
          TokenKind::{{kind.id}},
          {{pattern}},
          skip: {{skip}},
          priority: {{priority}},
          error_handler: {{on_error}}
        ))
      end
      
      macro error(name, message, help = nil)
        @rule_set.error_handlers[{{name}}] = ErrorHandler.new({{message}}, {{help}})
      end
      
      def lex(source_id : UInt32, source_map : Hecate::Core::SourceMap)
        Scanner.new(@rule_set, source_id, source_map).scan_all
      end
    end
    
    GeneratedLexer
  end
end
```

# Test Strategy:
Test macro expansion with various DSL configurations, verify enum generation, test compile-time errors for invalid DSL usage

# Subtasks:
## 1. Define DSL Macro Structure [pending]
### Dependencies: None
### Description: Create the base macro structure for the lexer DSL with proper block processing and code generation setup
### Details:
Implement the `define` macro in src/hecate/lex/dsl.cr that accepts a block and sets up the foundation for processing DSL commands. This includes creating the macro definition, establishing the code generation structure, and preparing for token enum generation.

## 2. Implement Token Enum Generation [pending]
### Dependencies: 14.1
### Description: Generate TokenKind enum at compile-time by extracting token definitions from the DSL block
### Details:
Create the compile-time logic to scan the DSL block for `token` calls and generate a TokenKind enum with all defined tokens plus the mandatory EOF token. Use Crystal's macro AST traversal to extract token names from the block body.

## 3. Build GeneratedLexer Class [pending]
### Dependencies: 14.2
### Description: Create the lexer class that will be instantiated with rules from the DSL block
### Details:
Implement the GeneratedLexer class within the macro that initializes a RuleSet, processes the DSL block in its constructor, and provides the lex method. Ensure proper initialization of the rule set with the EOF rule having lowest priority.

## 4. Implement DSL Commands [pending]
### Dependencies: 14.3
### Description: Create the token and error macro methods within GeneratedLexer for DSL command processing
### Details:
Implement the `token` macro that adds rules to the rule set with proper TokenKind enum values, patterns, skip flags, priorities, and error handlers. Also implement the `error` macro for defining named error handlers. Ensure all parameters are properly passed through to Rule creation.

## 5. Add Compile-Time Validation [pending]
### Dependencies: 14.4
### Description: Implement compile-time validation for DSL usage to catch errors early and provide helpful error messages
### Details:
Add validation to ensure token names are valid Crystal enum members, patterns are valid regex literals, priorities are numeric, and error handler references exist. Provide clear compile-time error messages for invalid DSL usage.

