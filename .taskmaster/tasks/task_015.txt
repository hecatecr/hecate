# Task ID: 15
# Title: Implement Scanner Algorithm
# Status: pending
# Dependencies: 12, 13, 14
# Priority: high
# Description: Build the core scanning algorithm with longest-match-wins strategy and error recovery
# Details:
Create src/hecate/lex/scanner.cr:
```crystal
module Hecate::Lex
  class Scanner(T)
    def initialize(@rule_set : RuleSet(T), @source_id : UInt32, 
                   @source_map : Hecate::Core::SourceMap)
      @source = @source_map.get(@source_id).not_nil!
      @text = @source.contents
      @pos = 0
      @tokens = [] of Token(T)
      @diagnostics = [] of Hecate::Core::Diagnostic
    end
    
    def scan_all : {Array(Token(T)), Array(Hecate::Core::Diagnostic)}
      while @pos < @text.size
        scan_next
      end
      
      # Add EOF token
      eof_span = Hecate::Core::Span.new(@source_id, @text.size, @text.size)
      @tokens << Token.new(T::EOF, eof_span)
      
      {@tokens, @diagnostics}
    end
    
    private def scan_next
      start_pos = @pos
      
      # Try each rule in priority order
      best_match = nil
      best_rule = nil
      
      @rule_set.rules.each do |rule|
        if match = rule.match_at(@text, @pos)
          if best_match.nil? || match[0].size > best_match[0].size
            best_match = match
            best_rule = rule
          elsif match[0].size == best_match[0].size && rule.priority > best_rule.not_nil!.priority
            best_match = match
            best_rule = rule
          end
        end
      end
      
      if best_match && best_rule
        # Create token unless skip rule
        unless best_rule.skip
          span = Hecate::Core::Span.new(@source_id, start_pos, start_pos + best_match[0].size)
          @tokens << Token.new(best_rule.kind, span)
        end
        @pos += best_match[0].size
      else
        # No match - error recovery
        handle_unmatched_input(start_pos)
      end
    end
    
    private def handle_unmatched_input(pos)
      # Skip one character and emit diagnostic
      span = Hecate::Core::Span.new(@source_id, pos, pos + 1)
      diagnostic = Hecate::Core.error("unexpected character '#{@text[pos]}'")
        .primary(span, "here")
        .build
      @diagnostics << diagnostic
      @pos += 1
    end
  end
end
```

# Test Strategy:
Test with overlapping patterns, verify longest-match-wins, test error recovery continues scanning, benchmark performance

# Subtasks:
## 1. Create Scanner Class Structure [pending]
### Dependencies: None
### Description: Implement the basic Scanner class with initialization, instance variables, and type parameters
### Details:
Set up the Scanner(T) class with proper initialization of @rule_set, @source_id, @source_map, @source, @text, @pos, @tokens, and @diagnostics. Ensure proper type constraints and nil handling for source retrieval.

## 2. Implement Longest-Match-Wins Algorithm [pending]
### Dependencies: 15.1
### Description: Build the core scan_next method with longest-match-wins strategy for rule matching
### Details:
Implement the algorithm that tries each rule in priority order, keeps track of the best match based on length, handles tie-breaking with priority values, and creates tokens for non-skip rules. Ensure proper position advancement after successful matches.

## 3. Implement Error Recovery Mechanism [pending]
### Dependencies: 15.1
### Description: Create robust error recovery that continues scanning after unmatched input
### Details:
Implement handle_unmatched_input method that skips single characters when no rules match, creates appropriate diagnostic messages with character details, maintains proper span tracking for error locations, and allows scanning to continue after errors.

## 4. Implement Main Scanning Loop [pending]
### Dependencies: 15.2, 15.3
### Description: Build the scan_all method that processes entire input and adds EOF token
### Details:
Create the main loop that calls scan_next until end of input, properly handles EOF token creation with correct span at text.size, returns both tokens and diagnostics as a tuple, and ensures all input is consumed.

## 5. Add Performance Optimizations [pending]
### Dependencies: 15.4
### Description: Optimize scanner for 100k+ tokens/second performance target
### Details:
Implement optimizations such as caching regex match results where possible, minimizing object allocations in hot paths, using efficient string slicing for position tracking, and pre-compiling patterns in RuleSet. Consider using StringScanner for better performance.

