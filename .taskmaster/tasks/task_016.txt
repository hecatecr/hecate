# Task ID: 16
# Title: Add Common Error Handlers
# Status: pending
# Dependencies: 15
# Priority: medium
# Description: Implement built-in error handlers for common lexical errors like unterminated strings
# Details:
Create src/hecate/lex/error_handlers.cr:
```crystal
module Hecate::Lex
  struct ErrorHandler
    getter message : String
    getter help : String?
    
    def initialize(@message, @help = nil)
    end
  end
  
  module CommonErrors
    UNTERMINATED_STRING = ErrorHandler.new(
      "unterminated string literal",
      "strings must be closed with a matching quote"
    )
    
    UNTERMINATED_COMMENT = ErrorHandler.new(
      "unterminated block comment",
      "block comments must be closed with */"
    )
    
    INVALID_ESCAPE = ErrorHandler.new(
      "invalid escape sequence",
      "valid escape sequences are: \\n \\r \\t \\\\ \\\""
    )
  end
  
  # Extend scanner to handle error handlers
  class Scanner(T)
    private def apply_error_handler(rule : Rule(T), span : Span, match : Regex::MatchData)
      if handler_name = rule.error_handler
        if handler = @rule_set.error_handlers[handler_name]?
          diagnostic = Hecate::Core.error(handler.message)
            .primary(span, "here")
          
          diagnostic = diagnostic.help(handler.help) if handler.help
          @diagnostics << diagnostic.build
        end
      end
    end
  end
end
```
Integrate error handler invocation into scanner when patterns match but indicate errors (e.g., unterminated string pattern).

# Test Strategy:
Test each common error pattern, verify diagnostic messages, ensure error recovery continues scanning after errors

# Subtasks:
## 1. Create Error Handler Structure [pending]
### Dependencies: None
### Description: Define the ErrorHandler struct and CommonErrors module with predefined error handlers
### Details:
Create src/hecate/lex/error_handlers.cr with ErrorHandler struct containing message and optional help fields. Define CommonErrors module with UNTERMINATED_STRING, UNTERMINATED_COMMENT, and INVALID_ESCAPE error handlers. Each handler should have descriptive messages and helpful suggestions for users.

## 2. Add Error Handler Storage to RuleSet [pending]
### Dependencies: 16.1
### Description: Extend RuleSet to store and manage error handlers by name
### Details:
Modify src/hecate/lex/rule_set.cr to add error_handlers property as Hash(Symbol, ErrorHandler). Add register_error_handler method to store handlers by symbolic name. Update RuleSet initialization to include default CommonErrors handlers automatically.

## 3. Extend Rule with Error Handler Reference [pending]
### Dependencies: 16.2
### Description: Add error_handler field to Rule struct to associate rules with error handlers
### Details:
Update src/hecate/lex/rule.cr to add optional error_handler : Symbol? field. Modify Rule initialization to accept error_handler parameter. This allows rules to reference error handlers by name when they match error patterns.

## 4. Implement Error Handler Application in Scanner [pending]
### Dependencies: 16.3
### Description: Add apply_error_handler method to Scanner class for generating diagnostics
### Details:
Extend src/hecate/lex/scanner.cr with apply_error_handler private method that takes rule, span, and match data. Method should look up error handler from rule_set, create diagnostic with error severity using handler's message and help text, and add to diagnostics array. Integrate with existing diagnostic builder API.

## 5. Integrate Error Handling into Scanning Loop [pending]
### Dependencies: 16.4
### Description: Modify scanner algorithm to invoke error handlers for error-indicating patterns
### Details:
Update scan_all method in Scanner to check if matched rule has associated error_handler. When error handler is present, call apply_error_handler instead of creating normal token. Ensure scanning continues after error to provide recovery. Add error recovery patterns for common cases like unterminated strings extending to end of line.

