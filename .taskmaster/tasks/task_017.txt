# Task ID: 17
# Title: Create Comprehensive Test Suite
# Status: pending
# Dependencies: 8, 9, 10, 15, 16
# Priority: high
# Description: Build test infrastructure with snapshot testing for diagnostics and golden files for token sequences
# Details:
Create spec/support/snapshot_helper.cr:
```crystal
module SnapshotHelper
  def assert_snapshot(name : String, actual : String)
    snapshot_dir = "spec/snapshots"
    Dir.mkdir_p(snapshot_dir)
    
    snapshot_file = File.join(snapshot_dir, "#{name}.snapshot")
    
    if File.exists?(snapshot_file)
      expected = File.read(snapshot_file)
      actual.should eq(expected)
    else
      File.write(snapshot_file, actual)
      pending "Snapshot created: #{snapshot_file}"
    end
  end
end
```

Create comprehensive test cases:
- spec/hecate/core/source_file_spec.cr (line offset calculation)
- spec/hecate/core/diagnostic_spec.cr (builder API)
- spec/hecate/core/renderer/tty_spec.cr (snapshot tests)
- spec/hecate/lex/scanner_spec.cr (token generation)
- spec/hecate/lex/dsl_spec.cr (macro expansion)

Add integration tests with sample languages.

# Test Strategy:
Run full test suite with coverage reporting, verify > 90% coverage, ensure all edge cases tested

# Subtasks:
## 1. Create Snapshot Testing Infrastructure [pending]
### Dependencies: None
### Description: Implement the core snapshot testing helper module with comparison and update capabilities
### Details:
Create spec/support/snapshot_helper.cr with SnapshotHelper module containing assert_snapshot method. Implement logic to create snapshot directories, write new snapshots when they don't exist, and compare actual output against existing snapshots. Add support for updating snapshots via environment variable UPDATE_SNAPSHOTS=1. Include proper error messages showing differences when snapshots don't match.

## 2. Implement Core Module Test Suite [pending]
### Dependencies: 17.1
### Description: Build comprehensive test coverage for hecate-core components including SourceFile, Position, Span, and Diagnostic
### Details:
Create spec files for core components: spec/hecate/core/source_file_spec.cr testing line offset calculation with various file formats (CRLF, LF, empty files, large files), spec/hecate/core/position_spec.cr testing coordinate conversions and edge cases, spec/hecate/core/span_spec.cr testing span operations and validation, spec/hecate/core/diagnostic_spec.cr testing the builder API and label management. Include edge cases like zero-length spans, out-of-bounds positions, and Unicode handling.

## 3. Create TTY Renderer Test Suite with Snapshots [pending]
### Dependencies: 17.1, 17.2
### Description: Develop snapshot-based tests for the TTY renderer to verify diagnostic output formatting
### Details:
Create spec/hecate/core/renderer/tty_spec.cr with comprehensive snapshot tests for various diagnostic scenarios: single-line errors, multi-line errors, multiple labels, different severity levels, and various terminal widths. Test NO_COLOR environment variable handling, line number formatting, source code highlighting, and proper alignment of diagnostic markers. Create snapshot files for each test case in spec/snapshots/tty_renderer/.

## 4. Build Lexer Module Test Infrastructure [pending]
### Dependencies: 17.1
### Description: Implement comprehensive tests for the lexer DSL and scanner components with golden file testing
### Details:
Create spec/hecate/lex/scanner_spec.cr testing token generation, position tracking, and error recovery. Create spec/hecate/lex/dsl_spec.cr testing the lexer definition DSL, token priorities, skip tokens, and state transitions. Implement golden file testing for token sequences in spec/golden/lexer/ directory. Test various language constructs: keywords, identifiers, operators, string literals with escapes, comments, and numeric literals.

## 5. Create Integration Test Suite with Sample Languages [pending]
### Dependencies: 17.1, 17.2, 17.3, 17.4
### Description: Develop end-to-end integration tests using sample language implementations
### Details:
Create spec/integration/ directory with sample language implementations: a simple arithmetic expression language, a basic JSON parser, and a minimal programming language with variables and functions. Each sample should test the full pipeline from lexing through parsing with comprehensive error scenarios. Include performance benchmarks comparing against reference implementations. Create spec/integration/helpers.cr with utilities for running full compilation pipelines.

