{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup hecate-ast shard structure and dependencies",
        "description": "Initialize the hecate-ast shard directory structure following Hecate monorepo conventions, configure shard.yml with proper dependencies, and set up development environment",
        "details": "Create shards/hecate-ast/ directory structure:\n- src/hecate-ast.cr (main entry point)\n- src/hecate/ast/ for module files\n- spec/ for tests with spec_helper.cr\n- Configure shard.yml with hecate-core dependency (github: hecatecr/hecate-core)\n- Add shard.dev.yml override for local development\n- Update root shard.yml to include hecate-ast path dependency\n- Create VERSION constant in Hecate::AST module\n- Set up .gitignore for Crystal artifacts",
        "testStrategy": "Verify directory structure matches other Hecate shards, ensure 'shards install' succeeds, confirm spec_helper.cr can require hecate-core/test_utils, validate module can be required from other shards",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create hecate-ast directory structure",
            "description": "Set up the basic directory structure for the hecate-ast shard following Hecate monorepo conventions",
            "dependencies": [],
            "details": "Create the following directory structure:\n- shards/hecate-ast/\n- shards/hecate-ast/src/\n- shards/hecate-ast/src/hecate/\n- shards/hecate-ast/src/hecate/ast/\n- shards/hecate-ast/spec/\n- shards/hecate-ast/spec/hecate/\n- shards/hecate-ast/spec/hecate/ast/\n- shards/hecate-ast/examples/\n- shards/hecate-ast/spec/fixtures/\n- shards/hecate-ast/spec/fixtures/golden/",
            "status": "done",
            "testStrategy": "Verify all directories exist with correct permissions, compare structure against existing shards like hecate-core and hecate-lex"
          },
          {
            "id": 2,
            "title": "Configure shard.yml and dependencies",
            "description": "Create and configure shard.yml with proper metadata and hecate-core dependency for production use",
            "dependencies": [
              "1.1"
            ],
            "details": "Create shards/hecate-ast/shard.yml with:\n- name: hecate-ast\n- version: 0.1.0\n- description: AST node definitions and utilities for Hecate\n- authors: [watzon]\n- crystal: \"~> 1.17\"\n- license: MIT\n- dependencies:\n    hecate-core:\n      github: hecatecr/hecate-core\n      version: \"~> 0.1.0\"",
            "status": "done",
            "testStrategy": "Run 'shards install' from shards/hecate-ast/ to verify dependency resolution, check that hecate-core is properly downloaded"
          },
          {
            "id": 3,
            "title": "Create main entry point and module structure",
            "description": "Set up the main hecate-ast.cr file and initial module structure with VERSION constant",
            "dependencies": [
              "1.1"
            ],
            "details": "Create src/hecate-ast.cr with:\n```crystal\nrequire \"./hecate/ast/*\"\n\nmodule Hecate::AST\n  VERSION = \"0.1.0\"\nend\n```\nAlso create src/hecate/ast/version.cr if needed for better organization",
            "status": "done",
            "testStrategy": "Ensure 'crystal build src/hecate-ast.cr' succeeds, verify module can be required, check VERSION constant is accessible"
          },
          {
            "id": 4,
            "title": "Set up spec_helper and test infrastructure",
            "description": "Configure spec_helper.cr to properly require hecate-core test utilities and set up testing environment",
            "dependencies": [
              "1.2",
              "1.3"
            ],
            "details": "Create spec/spec_helper.cr with:\n```crystal\nrequire \"spec\"\nrequire \"../src/hecate-ast\"\nrequire \"hecate-core/test_utils\"\n```\nCreate a basic spec file spec/hecate/ast/ast_spec.cr to verify setup:\n```crystal\nrequire \"../../spec_helper\"\n\ndescribe Hecate::AST do\n  it \"has a VERSION\" do\n    Hecate::AST::VERSION.should_not be_nil\n  end\nend\n```",
            "status": "done",
            "testStrategy": "Run 'crystal spec' from shards/hecate-ast/, verify test utilities from hecate-core are available, ensure basic spec passes"
          },
          {
            "id": 5,
            "title": "Update monorepo configuration",
            "description": "Add hecate-ast to the root shard.yml and create development override configuration",
            "dependencies": [
              "1.2"
            ],
            "details": "1. Update root shard.yml to include:\n```yaml\ndependencies:\n  # ... existing dependencies\n  hecate-ast:\n    path: shards/hecate-ast\n```\n2. Create shards/hecate-ast/shard.dev.yml:\n```yaml\ndependencies:\n  hecate-core:\n    path: ../hecate-core\n```\n3. Add .gitignore in shards/hecate-ast/ with:\n- /lib/\n- /bin/\n- /.shards/\n- *.dwarf",
            "status": "done",
            "testStrategy": "Run 'just test' from monorepo root to ensure hecate-ast is included, verify 'just test-shard ast' works, check that development dependencies resolve correctly"
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement base Node class with span tracking",
        "description": "Create the foundational Node abstract class that all AST nodes will inherit from, including automatic span tracking and core utilities",
        "details": "Implement in src/hecate/ast/node.cr:\n```crystal\nmodule Hecate::AST\n  abstract class Node\n    getter span : Hecate::Core::Span\n    \n    def initialize(@span : Hecate::Core::Span)\n    end\n    \n    abstract def accept(visitor)\n    abstract def children : Array(Node)\n    \n    def ==(other : self) : Bool\n      # Deep equality check\n    end\n    \n    def clone : self\n      # Deep clone implementation\n    end\n    \n    def to_s(io : IO) : Nil\n      # Debug string representation\n    end\n  end\nend\n```\nIntegrate with Hecate::Core::Span for source location tracking",
        "testStrategy": "Test span preservation through node creation, verify equality/clone work correctly with nested structures, ensure abstract methods are enforced, test to_s output format",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Node abstract class structure",
            "description": "Set up the basic Node abstract class with span field, constructor, and abstract method declarations",
            "dependencies": [],
            "details": "Create src/hecate/ast/node.cr with the Node abstract class inside Hecate::AST module. Include the span getter, initialize method that takes a Hecate::Core::Span parameter, and declare abstract methods for accept(visitor) and children. This forms the foundation that all AST nodes will inherit from.",
            "status": "done",
            "testStrategy": "Create a concrete test node class that inherits from Node, verify it must implement abstract methods, test that span is properly stored and accessible, ensure compilation fails without implementing required methods"
          },
          {
            "id": 2,
            "title": "Implement deep equality comparison",
            "description": "Add the == method to Node class that performs deep structural equality checks on AST nodes",
            "dependencies": [
              "2.1"
            ],
            "details": "Implement the ==(other : self) method that compares nodes by type and recursively compares all children. Should handle nil values, check that both nodes are same type, compare spans for equality, and recursively compare all child nodes. Consider performance implications for large trees.",
            "status": "done",
            "testStrategy": "Test equality between identical nodes, nodes with different spans but same structure, nodes with different children, different node types, and deeply nested structures. Verify reflexive, symmetric, and transitive properties."
          },
          {
            "id": 3,
            "title": "Implement deep clone functionality",
            "description": "Create the clone method that performs deep copying of entire AST subtrees",
            "dependencies": [
              "2.1",
              "2.2"
            ],
            "details": "Implement clone : self method that creates a deep copy of the node and all its children. Must handle circular references prevention, preserve exact span information, recursively clone all child nodes, and maintain the same structure. Consider using a visitor pattern or recursion with memoization.",
            "status": "done",
            "testStrategy": "Test cloning simple nodes, complex nested structures, verify cloned nodes are equal but not identical objects, ensure modifying clone doesn't affect original, test span preservation"
          },
          {
            "id": 4,
            "title": "Add debug string representation",
            "description": "Implement to_s(io : IO) method for human-readable debug output of AST nodes",
            "dependencies": [
              "2.1"
            ],
            "details": "Create to_s(io : IO) : Nil method that writes a compact, readable representation of the node to the IO. Should include node type name, span information in a compact format (e.g., 'NodeType[1:5-1:10]'), and potentially show key fields. Avoid deep recursion to prevent stack overflow on large trees.",
            "status": "done",
            "testStrategy": "Test output format for various node types, verify IO writing works correctly, test with nodes containing different span ranges, ensure output is readable and consistent"
          },
          {
            "id": 5,
            "title": "Add helper methods and integration tests",
            "description": "Create additional utility methods and comprehensive integration tests for the Node class",
            "dependencies": [
              "2.1",
              "2.2",
              "2.3",
              "2.4"
            ],
            "details": "Add useful helper methods like is_leaf? (returns true if children.empty?), depth calculation, node counting utilities. Create integration tests that verify Node class works correctly with hecate-core's Span class, test inheritance with a sample concrete node implementation, and ensure all abstract methods work as expected when implemented.",
            "status": "done",
            "testStrategy": "Create mock node implementations for testing, verify helper methods work correctly, test integration with Span from hecate-core, ensure abstract class contract is enforced, test performance with large tree structures"
          }
        ]
      },
      {
        "id": 3,
        "title": "Design and implement AST definition DSL core",
        "description": "Create the macro-based DSL that allows users to declaratively define AST node types with minimal syntax",
        "details": "Implement in src/hecate/ast/dsl.cr:\n```crystal\nmodule Hecate::AST\n  macro define(&block)\n    # Capture DSL context\n    @@node_definitions = [] of NodeDef\n    @@abstract_types = [] of Symbol\n    \n    # Execute user block\n    {{block.body}}\n    \n    # Generate code after capturing definitions\n    finalize_ast\n  end\n  \n  macro abstract(name)\n    # Track abstract base types\n  end\n  \n  macro node(definition)\n    # Parse: node Name < Parent, field: Type, field2: Type\n    # Store in @@node_definitions\n  end\nend\n```\nUse Crystal's macro system to parse DSL syntax and store node definitions for code generation",
        "testStrategy": "Test DSL parsing with various node definition syntaxes, verify abstract type tracking, ensure field type parsing handles complex types (Array, Union, Nil), test inheritance chain resolution",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define DSL context structures and storage",
            "description": "Create the data structures needed to capture and store AST node definitions and abstract types during macro execution",
            "dependencies": [],
            "details": "Create NodeDef struct to hold node metadata (name, parent, fields with types). Implement storage mechanisms for @@node_definitions and @@abstract_types that can be accessed during macro expansion. Handle field parsing to support simple types, generic types (Array(T)), unions, and nilable types.",
            "status": "done",
            "testStrategy": "Test NodeDef creation with various field type combinations, verify storage and retrieval of definitions during macro expansion, ensure abstract type tracking works correctly"
          },
          {
            "id": 2,
            "title": "Implement abstract type macro",
            "description": "Create the 'abstract' macro that registers abstract base types for the AST hierarchy",
            "dependencies": [
              "3.1"
            ],
            "details": "Implement the abstract macro to capture abstract type names and store them in @@abstract_types. Ensure the macro can handle symbols and validate that abstract types are defined before being used as parents. Add validation to prevent duplicate abstract type definitions.",
            "status": "done",
            "testStrategy": "Test abstract type registration with valid names, verify duplicate detection, ensure abstract types can be referenced as parents in node definitions"
          },
          {
            "id": 3,
            "title": "Implement node definition parser macro",
            "description": "Create the 'node' macro that parses node definitions with inheritance and field specifications",
            "dependencies": [
              "3.1"
            ],
            "details": "Parse the DSL syntax 'node Name < Parent, field: Type, field2: Type' using Crystal's macro system. Extract node name, parent class, and field definitions. Handle various field type syntaxes including primitives, custom types, arrays, unions, and nilable types. Store parsed information in @@node_definitions for later code generation.",
            "status": "done",
            "testStrategy": "Test parsing of simple nodes, nodes with inheritance, nodes with complex field types (Array, Union, Nil), verify error handling for invalid syntax"
          },
          {
            "id": 4,
            "title": "Implement define block macro with context setup",
            "description": "Create the main 'define' macro that establishes the DSL context and executes the user block",
            "dependencies": [
              "3.1",
              "3.2",
              "3.3"
            ],
            "details": "Set up the macro context with empty @@node_definitions and @@abstract_types collections. Execute the provided block body to capture all DSL calls. Ensure proper scoping so nested define blocks don't interfere. Add validation for the overall AST structure before calling finalize_ast.",
            "status": "done",
            "testStrategy": "Test define block with multiple node definitions, verify proper context isolation, ensure block execution captures all DSL calls correctly"
          },
          {
            "id": 5,
            "title": "Create finalize_ast macro for code generation",
            "description": "Implement the finalize_ast macro that processes collected definitions and triggers actual code generation",
            "dependencies": [
              "3.4"
            ],
            "details": "Process all collected node definitions and abstract types. Validate inheritance chains (ensure parents exist and are either abstract or other nodes). Sort definitions topologically to handle dependencies. Prepare data structures for the node generator macro. Trigger the actual class generation process.",
            "status": "done",
            "testStrategy": "Test finalization with valid AST hierarchies, verify inheritance validation catches undefined parents, ensure topological sorting handles complex dependency graphs"
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement node class code generation",
        "description": "Create the macro logic that generates complete node classes from DSL definitions, including constructors, getters, and visitor pattern support",
        "details": "Implement in src/hecate/ast/macros/node_generator.cr:\n```crystal\nmacro generate_node_class(name, parent, fields)\n  class {{name}} < {{parent}}\n    # Generate getters for each field\n    {% for field in fields %}\n      getter {{field.name}} : {{field.type}}\n    {% end %}\n    \n    def initialize(@span : Hecate::Core::Span, {% for field in fields %}@{{field.name}} : {{field.type}}, {% end %})\n      super(@span)\n    end\n    \n    def accept(visitor)\n      visitor.visit_{{name.downcase}}(self)\n    end\n    \n    def children : Array(Node)\n      result = [] of Node\n      {% for field in fields %}\n        {% if field.type < Node %}\n          result << @{{field.name}}\n        {% elsif field.type.is_a?(Generic) && field.type.name == \"Array\" %}\n          result.concat(@{{field.name}})\n        {% end %}\n      {% end %}\n      result\n    end\n  end\nend\n```",
        "testStrategy": "Generate sample nodes and verify all methods are present, test field access and initialization, verify children extraction handles single nodes/arrays/optionals correctly, ensure visitor pattern integration works",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create macro field parsing logic",
            "description": "Implement the logic to parse and validate field definitions within the node generation macro, handling field names, types, and optional modifiers",
            "dependencies": [],
            "details": "Create helper macros to parse field definitions, extract field names and types, validate type syntax, handle optional fields (e.g., field? : Type?), and ensure proper macro variable handling. This includes creating Field struct to hold parsed field metadata.",
            "status": "done",
            "testStrategy": "Test parsing of various field types including primitives, custom types, generics, and optionals. Verify error handling for invalid field syntax. Test edge cases like empty fields and duplicate field names."
          },
          {
            "id": 2,
            "title": "Generate constructor and getter methods",
            "description": "Implement the macro logic that generates the constructor method with proper parameter handling and getter methods for all defined fields",
            "dependencies": [
              "4.1"
            ],
            "details": "Generate initialize method with @span parameter and all field parameters in correct order. Create getter methods for each field with proper type annotations. Handle optional fields in constructor signature. Ensure proper super call to parent class constructor.",
            "status": "done",
            "testStrategy": "Generate test nodes with various field combinations, verify constructor accepts all parameters in correct order, test getter methods return correct values, ensure optional fields work correctly in constructor."
          },
          {
            "id": 3,
            "title": "Implement visitor pattern accept method",
            "description": "Generate the accept method that integrates with the visitor pattern, creating appropriate visit method names based on node class names",
            "dependencies": [
              "4.1"
            ],
            "details": "Generate accept method that calls visitor.visit_{{name.downcase}}(self). Handle name transformation for multi-word class names (e.g., BinaryExpr -> visit_binary_expr). Ensure compatibility with Visitor base class interface.",
            "status": "done",
            "testStrategy": "Test accept method generation for various node names, verify correct visitor method names are generated, test integration with mock visitor implementations, ensure name transformations handle edge cases."
          },
          {
            "id": 4,
            "title": "Create children extraction logic",
            "description": "Implement the children method that intelligently extracts child nodes from fields based on their types, handling single nodes, arrays, and optional nodes",
            "dependencies": [
              "4.1",
              "4.2"
            ],
            "details": "Generate children method that returns Array(Node). Detect fields that are Node subclasses and add them to result. Handle Array fields containing nodes by using concat. Skip non-node fields. Handle optional node fields (check for nil). Support nested generic types like Array(Array(Node)).",
            "status": "done",
            "testStrategy": "Test children extraction with nodes containing single child nodes, array fields, optional fields, mixed node and non-node fields. Verify correct handling of nil values and empty arrays."
          },
          {
            "id": 5,
            "title": "Add macro validation and error handling",
            "description": "Implement comprehensive validation within the macro to ensure correct usage and provide helpful error messages for common mistakes",
            "dependencies": [
              "4.1",
              "4.2",
              "4.3",
              "4.4"
            ],
            "details": "Validate that parent class exists and is a valid Node subclass. Check for reserved field names that might conflict with Node methods. Validate field type syntax at compile time. Provide clear error messages for invalid macro usage. Add compile-time checks for circular dependencies in field types.",
            "status": "done",
            "testStrategy": "Test error messages for invalid parent classes, duplicate field names, reserved names, invalid type syntax. Verify helpful error messages guide users to correct usage. Test edge cases like empty node definitions."
          }
        ]
      },
      {
        "id": 5,
        "title": "Generate Visitor pattern infrastructure",
        "description": "Automatically generate the abstract Visitor class with visit methods for all defined node types and implement the visitor pattern plumbing",
        "details": "Implement in src/hecate/ast/macros/visitor_generator.cr:\n```crystal\nmacro finalize_ast\n  # Generate abstract visitor\n  abstract class Visitor(T)\n    {% for node in @@node_definitions %}\n      abstract def visit_{{node.name.downcase}}(node : {{node.name}}) : T\n    {% end %}\n    \n    def visit(node : Node) : T\n      node.accept(self)\n    end\n  end\n  \n  # Generate concrete visitor base for transformations\n  abstract class Transformer < Visitor(Node)\n    {% for node in @@node_definitions %}\n      def visit_{{node.name.downcase}}(node : {{node.name}}) : Node\n        # Default: reconstruct with visited children\n        # Implementation depends on node fields\n      end\n    {% end %}\n  end\nend\n```\nEnsure type parameter T allows flexible return types for different visitor use cases",
        "testStrategy": "Create test visitor implementations, verify all node types have corresponding visit methods, test visit dispatch mechanism, ensure transformer base class provides sensible defaults",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create visitor_generator.cr file with base macro structure",
            "description": "Set up the initial file structure for the visitor pattern generator including module definition and macro skeleton",
            "dependencies": [],
            "details": "Create src/hecate/ast/macros/visitor_generator.cr with module Hecate::AST containing the finalize_ast macro. Set up the basic structure to iterate over @@node_definitions and prepare for visitor class generation. Include proper file headers and Crystal documentation.",
            "status": "done",
            "testStrategy": "Verify file exists at correct path, ensure it can be required without errors, check that the macro is defined within the correct module namespace"
          },
          {
            "id": 2,
            "title": "Implement abstract Visitor(T) class generation",
            "description": "Generate the abstract Visitor class with type parameter T and abstract visit methods for all node types",
            "dependencies": [
              "5.1"
            ],
            "details": "Within the finalize_ast macro, implement the generation of abstract class Visitor(T) with: abstract visit methods for each node type using visit_{{node.name.downcase}} naming convention, a generic visit(node : Node) : T method that delegates to node.accept(self), and proper type annotations for flexible return types.",
            "status": "done",
            "testStrategy": "Create test nodes and verify Visitor class is generated with all expected abstract methods, test that type parameter T allows various return types (Node, String, Int32, etc.), ensure visit method properly delegates to node's accept method"
          },
          {
            "id": 3,
            "title": "Add accept method generation to Node classes",
            "description": "Modify the node generation logic to automatically add accept methods to all generated node classes",
            "dependencies": [
              "5.2"
            ],
            "details": "Update the node generation macro (likely in dsl.cr or node_generator.cr) to add: def accept(visitor) : visitor.visit_{{self.class.name.downcase}}(self) end to each generated node class. Ensure the method signature is compatible with the abstract accept method in the base Node class.",
            "status": "done",
            "testStrategy": "Verify each generated node has an accept method, test that accept correctly calls the appropriate visit method on the visitor, ensure polymorphic dispatch works correctly with inheritance hierarchies"
          },
          {
            "id": 4,
            "title": "Implement Transformer base class with default implementations",
            "description": "Create the Transformer class that extends Visitor(Node) with sensible default implementations for node reconstruction",
            "dependencies": [
              "5.2",
              "5.3"
            ],
            "details": "Generate abstract class Transformer < Visitor(Node) with default visit implementations that: recursively visit all child nodes based on node field definitions, reconstruct nodes with visited children while preserving spans, handle different field types appropriately (Node, Array(Node), Node?, etc.), provide a base for custom transformations.",
            "status": "done",
            "testStrategy": "Test default transformation preserves AST structure, verify child nodes are visited recursively, ensure spans are preserved during transformation, test with nodes containing various field types"
          },
          {
            "id": 5,
            "title": "Add macro support for custom visitor hooks and configuration",
            "description": "Extend the visitor generation to support customization options and hooks for special visitor behavior",
            "dependencies": [
              "5.4"
            ],
            "details": "Add macro parameters to control: whether to generate Transformer class, custom visitor base class names, additional visitor methods or hooks, visitor interface variations (e.g., visitors with context parameters). Ensure backward compatibility with default behavior.",
            "status": "done",
            "testStrategy": "Test visitor generation with various configuration options, verify custom base class names work correctly, ensure additional methods are properly integrated, test that default behavior remains unchanged when no options provided"
          }
        ]
      },
      {
        "id": 6,
        "title": "Implement tree traversal utilities",
        "description": "Create comprehensive tree walking algorithms including pre-order, post-order, level-order traversal and search utilities",
        "details": "Implement in src/hecate/ast/traversal.cr:\n```crystal\nmodule Hecate::AST::TreeWalk\n  def self.preorder(node : Node, &block : Node ->)\n    block.call(node)\n    node.children.each { |child| preorder(child, &block) }\n  end\n  \n  def self.postorder(node : Node, &block : Node ->)\n    node.children.each { |child| postorder(child, &block) }\n    block.call(node)\n  end\n  \n  def self.level_order(node : Node, &block : Node ->)\n    queue = Deque(Node).new([node])\n    while node = queue.shift?\n      block.call(node)\n      queue.concat(node.children)\n    end\n  end\n  \n  def self.find_all(node : Node, type : T.class) : Array(T) forall T\n    results = [] of T\n    preorder(node) do |n|\n      results << n if n.is_a?(T)\n    end\n    results\n  end\n  \n  def self.with_depth(node : Node, depth = 0, &block : Node, Int32 ->)\n    block.call(node, depth)\n    node.children.each { |child| with_depth(child, depth + 1, &block) }\n  end\nend\n```",
        "testStrategy": "Test each traversal order with complex AST structures, verify find_all returns correct typed results, test depth tracking accuracy, benchmark performance on large trees",
        "priority": "medium",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create core traversal module and base methods",
            "description": "Set up the TreeWalk module structure and implement the basic preorder and postorder traversal methods",
            "dependencies": [],
            "details": "Create src/hecate/ast/traversal.cr with the Hecate::AST::TreeWalk module. Implement preorder and postorder methods that accept a node and a block, recursively traversing the tree in the appropriate order. Ensure proper handling of the node.children array.",
            "status": "done",
            "testStrategy": "Create simple test trees with known structures and verify traversal order by collecting visited nodes. Test with single nodes, linear chains, and balanced trees."
          },
          {
            "id": 2,
            "title": "Implement level-order traversal using queue",
            "description": "Add breadth-first traversal capability using a queue-based approach for level-order tree walking",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement the level_order method using Crystal's Deque collection. Initialize with the root node, process nodes level by level by dequeuing and enqueuing children. Ensure proper handling of empty trees and single-node trees.",
            "status": "done",
            "testStrategy": "Test with multi-level trees to verify nodes are visited in breadth-first order. Compare results against expected level-by-level node sequences."
          },
          {
            "id": 3,
            "title": "Add type-safe find_all search utility",
            "description": "Implement a generic method to find all nodes of a specific type within the AST using Crystal's forall constraint",
            "dependencies": [
              "6.1"
            ],
            "details": "Create the find_all method that accepts a node and a type parameter, returning an array of all matching nodes. Use the preorder traversal internally and Crystal's is_a? check for type matching. Ensure proper generic type constraints with forall T.",
            "status": "done",
            "testStrategy": "Create ASTs with mixed node types and search for specific types. Verify all matching nodes are found and returned in preorder sequence."
          },
          {
            "id": 4,
            "title": "Implement depth-aware traversal method",
            "description": "Add traversal capability that tracks and provides the depth of each node during tree walking",
            "dependencies": [
              "6.1"
            ],
            "details": "Implement with_depth method that passes both the node and its depth to the provided block. Start with depth 0 at root and increment for each level. Ensure proper depth tracking through recursive calls.",
            "status": "done",
            "testStrategy": "Traverse trees of known depth and verify each node receives the correct depth value. Test with unbalanced trees to ensure depth is tracked per path."
          },
          {
            "id": 5,
            "title": "Add comprehensive specs and performance benchmarks",
            "description": "Create thorough test coverage for all traversal methods and establish performance benchmarks for large tree structures",
            "dependencies": [
              "6.1",
              "6.2",
              "6.3",
              "6.4"
            ],
            "details": "Write specs in spec/hecate/ast/traversal_spec.cr covering all traversal methods with various tree shapes. Include edge cases like empty children arrays and deeply nested structures. Add benchmarks to measure traversal performance on trees with 1000+ nodes.",
            "status": "done",
            "testStrategy": "Use property-based testing to generate random tree structures and verify traversal invariants. Benchmark against target of 100k+ nodes/second traversal speed."
          }
        ]
      },
      {
        "id": 7,
        "title": "Add pattern matching and type discrimination support",
        "description": "Enhance generated nodes with Crystal pattern matching capabilities and efficient type discrimination for case expressions",
        "details": "Extend node generation to support Crystal's case/when:\n```crystal\n# In node generator, ensure proper is_a? behavior\n# Crystal's pattern matching should work automatically\n# Add helper methods for common patterns:\n\nmodule Hecate::AST\n  # Generate type predicates\n  {% for node in @@node_definitions %}\n    class {{node.name}}\n      def {{node.name.downcase}}?\n        true\n      end\n    end\n    \n    class Node\n      def {{node.name.downcase}}?\n        false\n      end\n    end\n  {% end %}\nend\n```\nLeverage Crystal's built-in pattern matching with proper type hierarchy",
        "testStrategy": "Test case/when statements with all node types, verify type predicates work correctly, ensure exhaustive pattern matching is possible, test performance of type discrimination",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement type predicate generation system",
            "description": "Create the macro logic to generate type predicate methods (e.g., add?, int_literal?) for each node type",
            "dependencies": [],
            "details": "In src/hecate/ast/macros/type_predicates.cr, implement macro that generates predicate methods for each node type. The macro should iterate through @@node_definitions and create both positive predicates on the specific node class (returning true) and negative predicates on the base Node class (returning false). This enables idiomatic Crystal code like `if node.binary_expr?`",
            "status": "done",
            "testStrategy": "Create sample nodes and verify all predicate methods are generated correctly, test that predicates return true only for matching types, ensure inheritance works properly (child node predicates), verify performance is optimal with inline methods"
          },
          {
            "id": 2,
            "title": "Add pattern matching support with case/when",
            "description": "Ensure generated nodes work seamlessly with Crystal's case/when pattern matching",
            "dependencies": [
              "7.1"
            ],
            "details": "Verify that the generated node hierarchy properly supports Crystal's built-in pattern matching. Add any necessary type annotations or method overrides to ensure case/when statements work efficiently. May need to adjust node class definitions to ensure proper is_a? behavior and type inference. Document best practices for using pattern matching with AST nodes",
            "status": "done",
            "testStrategy": "Write comprehensive case/when tests covering all node types, test nested pattern matching, verify exhaustiveness checking works, benchmark pattern matching performance against manual type checks"
          },
          {
            "id": 3,
            "title": "Create type discrimination helper methods",
            "description": "Implement utility methods for efficient type discrimination in visitor patterns and transformations",
            "dependencies": [
              "7.1",
              "7.2"
            ],
            "details": "Add helper methods to the Node base class for common discrimination patterns: node_type method returning a symbol, is_expression?/is_statement? categorization methods, and potentially a type_id for fast integer-based switching. These helpers complement the predicate methods for scenarios requiring bulk type handling",
            "status": "done",
            "testStrategy": "Test type discrimination in visitor implementations, verify helper methods work with all node types, ensure categorization methods (expression/statement) are correct, benchmark performance of different discrimination approaches"
          },
          {
            "id": 4,
            "title": "Implement exhaustive pattern matching helpers",
            "description": "Create utilities to ensure exhaustive pattern matching and provide compile-time guarantees",
            "dependencies": [
              "7.2",
              "7.3"
            ],
            "details": "Develop macros or methods that help ensure exhaustive pattern matching when handling AST nodes. This could include an exhaustive_case macro that verifies all node types are handled, or visitor validation that ensures all visit methods are implemented. Add documentation showing idiomatic exhaustive matching patterns",
            "status": "done",
            "testStrategy": "Test exhaustive matching with incomplete case statements (should fail compilation), verify all node types are covered, test with node hierarchy changes, ensure helpful error messages for missing cases"
          },
          {
            "id": 5,
            "title": "Add pattern matching examples and documentation",
            "description": "Create comprehensive examples showing best practices for pattern matching with AST nodes",
            "dependencies": [
              "7.1",
              "7.2",
              "7.3",
              "7.4"
            ],
            "details": "Write example code demonstrating various pattern matching scenarios: simple type discrimination, nested pattern matching, using guards with patterns, combining predicates with case/when, and performance considerations. Add inline documentation to generated code explaining pattern matching capabilities. Create a guide in docs/ showing idiomatic AST traversal patterns",
            "status": "done",
            "testStrategy": "Ensure all examples compile and run correctly, verify examples cover common use cases, test that documentation code snippets are accurate, validate performance claims in documentation"
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement builder pattern DSL",
        "description": "Create an optional builder pattern API for ergonomic AST construction in tests and examples",
        "details": "Implement in src/hecate/ast/builder.cr:\n```crystal\nmodule Hecate::AST\n  macro generate_builders(enabled = true)\n    {% if enabled %}\n      module Builder\n        extend self\n        \n        {% for node in @@node_definitions %}\n          def {{node.name.downcase}}({% for field in node.fields %}{{field.name}} : {{field.type}}, {% end %}span = Span.new(0, 0))\n            {{node.name}}.new(span, {% for field in node.fields %}{{field.name}}, {% end %})\n          end\n        {% end %}\n        \n        def build(&block)\n          with self yield\n        end\n      end\n    {% end %}\n  end\nend\n```\nProvide fluent API for building AST structures without manual span tracking",
        "testStrategy": "Build sample ASTs using builder DSL, verify all node types have builder methods, test nested construction, ensure optional span parameter works correctly",
        "priority": "low",
        "dependencies": [
          5
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create builder module structure and basic setup",
            "description": "Set up the Builder module structure with necessary imports and foundation for the DSL",
            "dependencies": [],
            "details": "Create src/hecate/ast/builder.cr with the module structure, extend self for module methods, and set up the basic framework for the generate_builders macro. Include necessary requires for Span and node definitions.",
            "status": "pending",
            "testStrategy": "Test that the Builder module is properly defined and accessible, verify that it can be included/extended without errors"
          },
          {
            "id": 2,
            "title": "Implement generate_builders macro with node method generation",
            "description": "Create the core macro that iterates through node definitions and generates builder methods",
            "dependencies": [
              "8.1"
            ],
            "details": "Implement the generate_builders macro that accepts an enabled parameter (default true). The macro should iterate through @@node_definitions and generate a method for each node type with lowercase naming convention. Each method should accept the node's fields as parameters plus an optional span parameter with default Span.new(0, 0).",
            "status": "pending",
            "testStrategy": "Test that builder methods are generated for all defined node types, verify method signatures match node field requirements, ensure optional span parameter works correctly"
          },
          {
            "id": 3,
            "title": "Implement build block method for DSL syntax",
            "description": "Add the build method that enables block-based DSL construction with implicit receiver",
            "dependencies": [
              "8.2"
            ],
            "details": "Implement the build(&block) method that uses 'with self yield' to allow DSL-style construction without explicitly referencing Builder. This enables syntax like: Builder.build { add(int(1), int(2)) }",
            "status": "pending",
            "testStrategy": "Test that build blocks properly delegate method calls to Builder module, verify nested construction works, ensure return values are correctly propagated"
          },
          {
            "id": 4,
            "title": "Add advanced builder features for nested structures",
            "description": "Enhance builder methods to handle complex nested AST construction patterns",
            "dependencies": [
              "8.3"
            ],
            "details": "Add support for building nested structures efficiently, including automatic span calculation for parent nodes based on child spans, support for optional fields with nil defaults, and convenience methods for common patterns like binary operations or block statements.",
            "status": "pending",
            "testStrategy": "Test complex nested AST construction, verify span propagation in nested structures, test optional field handling, ensure deeply nested structures build correctly"
          },
          {
            "id": 5,
            "title": "Create comprehensive examples and integration tests",
            "description": "Develop examples showing builder DSL usage and write integration tests with real AST structures",
            "dependencies": [
              "8.4"
            ],
            "details": "Create example files demonstrating builder usage for common patterns (expressions, statements, declarations). Write integration tests that build complete AST structures using the builder DSL and verify they match manually constructed ASTs. Include examples in documentation showing before/after comparisons of manual vs builder construction.",
            "status": "pending",
            "testStrategy": "Test that all example code runs without errors, verify builder-constructed ASTs are identical to manually constructed ones, ensure examples cover all major node types and patterns"
          }
        ]
      },
      {
        "id": 9,
        "title": "Add debugging and pretty printing utilities",
        "description": "Implement comprehensive debugging support including pretty printing, S-expression format, and JSON serialization for AST nodes",
        "details": "Implement in src/hecate/ast/pretty_printer.cr:\n```crystal\nmodule Hecate::AST\n  class PrettyPrinter < Visitor(String)\n    def initialize(@indent_size = 2)\n      @depth = 0\n    end\n    \n    # Implement visit methods for each node type\n    # with appropriate formatting\n  end\n  \n  class Node\n    def to_sexp : String\n      SExpPrinter.new.visit(self)\n    end\n    \n    def to_json(json : JSON::Builder)\n      json.object do\n        json.field \"type\", self.class.name\n        json.field \"span\", @span.to_json\n        # Serialize fields\n      end\n    end\n  end\nend\n```\nSupport multiple output formats for different debugging scenarios",
        "testStrategy": "Test pretty printing on complex expressions, verify S-expression format is valid, ensure JSON output can be parsed back, test indentation and formatting rules",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement PrettyPrinter visitor class",
            "description": "Create the PrettyPrinter visitor that traverses AST nodes and generates human-readable formatted output",
            "dependencies": [],
            "details": "Implement in src/hecate/ast/pretty_printer.cr with base visitor pattern, depth tracking for indentation, configurable indent size, and helper methods for formatting common patterns like lists and nested structures",
            "status": "done",
            "testStrategy": "Test with various AST structures including deeply nested nodes, verify correct indentation levels, ensure line breaks are placed appropriately, test with different indent sizes"
          },
          {
            "id": 2,
            "title": "Add S-expression printer implementation",
            "description": "Create SExpPrinter visitor for generating S-expression representations of AST nodes",
            "dependencies": [],
            "details": "Implement SExpPrinter class that outputs Lisp-style S-expressions, handle proper parentheses nesting, escape special characters in string literals, format lists and atoms correctly",
            "status": "done",
            "testStrategy": "Verify S-expression output matches expected format, test with complex nested expressions, ensure special characters are escaped, validate output can be parsed by S-expression parsers"
          },
          {
            "id": 3,
            "title": "Implement JSON serialization for AST nodes",
            "description": "Add JSON::Serializable support and custom to_json methods for all AST node types",
            "dependencies": [],
            "details": "Add to_json(JSON::Builder) method to base Node class, serialize node type name, span information, and all node-specific fields, handle recursive serialization of child nodes, ensure proper JSON structure",
            "status": "done",
            "testStrategy": "Test JSON output is valid and parseable, verify all node fields are included, test round-trip serialization/deserialization, ensure spans are preserved in JSON format"
          },
          {
            "id": 4,
            "title": "Create debug output formatting utilities",
            "description": "Implement additional debugging helpers including compact string representation and tree visualization",
            "dependencies": [
              "9.1",
              "9.2"
            ],
            "details": "Add debug_tree method for ASCII tree visualization, implement compact single-line format for logging, create configurable verbosity levels, add source code snippet extraction using span information",
            "status": "done",
            "testStrategy": "Test tree visualization with various AST structures, verify compact format fits on single line, test source snippet extraction with different span sizes, validate verbosity filtering works correctly"
          },
          {
            "id": 5,
            "title": "Add format-specific configuration and integration",
            "description": "Create configuration options for output formats and integrate with existing AST infrastructure",
            "dependencies": [
              "9.1",
              "9.2",
              "9.3",
              "9.4"
            ],
            "details": "Add PrettyPrintOptions struct for customization, implement format auto-detection based on output destination, integrate with existing Visitor pattern infrastructure, add convenience methods to Node class for all formats",
            "status": "done",
            "testStrategy": "Test configuration options affect output correctly, verify format auto-detection works for TTY vs file output, ensure all convenience methods work on any Node subclass, test integration with existing visitor pattern"
          }
        ]
      },
      {
        "id": 10,
        "title": "Create validation framework for AST nodes",
        "description": "Implement a validation system that allows custom validation rules to be attached to node definitions and provides structural validation",
        "details": "Implement in src/hecate/ast/validator.cr:\n```crystal\nmodule Hecate::AST\n  # Extend DSL to support validation blocks\n  macro node(definition, &block)\n    # ... existing node generation ...\n    \n    {% if block %}\n      class {{node_name}}\n        def validate : Array(Hecate::Core::Diagnostic)?\n          errors = [] of Hecate::Core::Diagnostic\n          {{block.body}}\n          errors.empty? ? nil : errors\n        end\n      end\n    {% end %}\n  end\n  \n  class ASTValidator < Visitor(Array(Hecate::Core::Diagnostic))\n    def initialize\n      @errors = [] of Hecate::Core::Diagnostic\n    end\n    \n    def visit(node : Node)\n      if node.responds_to?(:validate)\n        @errors.concat(node.validate || [] of Hecate::Core::Diagnostic)\n      end\n      super\n    end\n  end\nend\n```",
        "testStrategy": "Test custom validation rules on nodes, verify diagnostic generation with proper spans, test structural validation (orphaned nodes, cycles), ensure validation doesn't impact performance",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design validation rule DSL syntax and macro structure",
            "description": "Define the syntax for attaching validation rules to AST nodes within the DSL, including how rules are specified in the node definition block and how they integrate with the existing macro system",
            "dependencies": [],
            "details": "Research and design the syntax for validation blocks within node definitions. Consider how to pass validation logic as a macro block, how to access node fields within validation rules, and how to integrate with the existing node macro. Design should support both simple field validations and complex cross-field validations. Example syntax: `node Add < BinaryOp, left: Expr, right: Expr do validate { errors << diagnostic if left.type != right.type } end`\n<info added on 2025-07-26T01:56:09.117Z>\n**Validation DSL Design Completed Successfully**\n\nThe validation rule syntax has been finalized with a block-based approach that integrates cleanly with the existing node macro system. The design supports `node Name < Parent, field: Type do validate do ... end end` syntax with direct field access within validation blocks.\n\nKey design decisions made:\n- Uses `&validation_block` parameter to capture validation logic during macro expansion\n- Provides helper methods (`error()`, `warning()`, `note()`) for ergonomic diagnostic creation\n- ASTValidator class design handles traversal and error collection across the entire AST\n- Full integration with Hecate::Core diagnostic system preserves source spans and formatting\n- Optional validation blocks ensure backward compatibility with existing node definitions\n\nThe syntax follows Crystal conventions using familiar block patterns similar to `record` macros and spec DSLs. Cross-field validations are supported through direct access to all node fields within the validation context.\n\nDesign is complete and ready for macro implementation in subtask 10.2.\n</info added on 2025-07-26T01:56:09.117Z>",
            "status": "done",
            "testStrategy": "Create test cases with various validation rule syntaxes, verify macro expansion handles validation blocks correctly, test that validation rules can access node fields and methods"
          },
          {
            "id": 2,
            "title": "Extend node macro to capture and generate validation methods",
            "description": "Modify the existing node generation macro to optionally accept a validation block and generate the validate method on node classes when validation rules are provided",
            "dependencies": [
              "10.1"
            ],
            "details": "Update the node macro in the AST DSL to accept an optional block parameter. When a block is provided, generate a validate method that returns Array(Hecate::Core::Diagnostic)? with the validation logic from the block. Ensure the generated method has access to node instance variables and can create diagnostics with proper spans. Handle cases where no validation block is provided (no validate method generated).",
            "status": "in-progress",
            "testStrategy": "Test node generation with and without validation blocks, verify generated validate methods compile correctly, ensure validation logic can access all node fields and the span property"
          },
          {
            "id": 3,
            "title": "Implement ASTValidator visitor class",
            "description": "Create the ASTValidator class that extends the Visitor pattern to traverse AST nodes and collect validation errors from nodes that define validation rules",
            "dependencies": [
              "10.2"
            ],
            "details": "Implement ASTValidator as a concrete visitor that accumulates diagnostics. Override the visit method to check if nodes respond to validate, call the method if present, and collect any returned diagnostics. Ensure proper error accumulation and handle nested node validation. The visitor should maintain an errors array and provide methods to retrieve all collected diagnostics after traversal.",
            "status": "pending",
            "testStrategy": "Test validator traversal on AST with mixed validated/non-validated nodes, verify all validation errors are collected, test deep AST structures, ensure visitor doesn't fail on nodes without validation"
          },
          {
            "id": 4,
            "title": "Add structural validation capabilities",
            "description": "Implement additional validation logic in ASTValidator to detect structural issues like orphaned nodes, circular references, and invalid parent-child relationships beyond custom validation rules",
            "dependencies": [
              "10.3"
            ],
            "details": "Extend ASTValidator with built-in structural checks: detect nodes without proper parent references, identify circular dependencies in the AST, validate that child nodes match expected types based on field definitions, and check for required fields that are nil. These checks should run alongside custom validation rules and generate appropriate diagnostics with clear error messages and accurate spans.",
            "status": "pending",
            "testStrategy": "Create ASTs with various structural issues (cycles, orphans, type mismatches), verify each issue generates appropriate diagnostics, test that structural validation doesn't interfere with custom rules"
          },
          {
            "id": 5,
            "title": "Create comprehensive test suite and documentation",
            "description": "Develop thorough tests for the validation framework including unit tests, integration tests with real AST nodes, and performance benchmarks to ensure validation doesn't significantly impact AST processing",
            "dependencies": [
              "10.4"
            ],
            "details": "Write spec files covering: DSL syntax variations, validation rule complexity (simple field checks to complex multi-field validations), diagnostic generation with accurate spans, structural validation edge cases, performance tests with large ASTs (10k+ nodes), and integration with existing visitor pattern. Create example validations for common patterns like type checking, range validation, and reference validation. Document the validation API with Crystal doc comments.",
            "status": "pending",
            "testStrategy": "Use snapshot testing for diagnostic output, benchmark validation overhead on various AST sizes, test error cases and edge conditions, verify validation integrates smoothly with other AST operations"
          }
        ]
      },
      {
        "id": 11,
        "title": "Optimize performance and memory usage",
        "description": "Profile and optimize the generated code for minimal overhead, implement node pooling for common cases, and ensure efficient memory usage",
        "details": "Performance optimizations:\n1. Use struct for leaf nodes when possible\n2. Implement copy-on-write for transformations\n3. Add node pooling for literals:\n```crystal\nmodule Hecate::AST\n  # Pool common integer literals\n  class IntLit\n    @@pool = {} of Int32 => IntLit\n    \n    def self.new(value : Int32, span : Span)\n      if -128 <= value <= 127\n        @@pool[value] ||= super\n      else\n        super\n      end\n    end\n  end\nend\n```\n4. Optimize visitor dispatch with jump tables\n5. Benchmark against manual implementation\n6. Profile memory allocation patterns",
        "testStrategy": "Benchmark AST creation/traversal/transformation speed, measure memory usage for large ASTs, compare performance to manual implementation, verify optimizations don't break functionality",
        "priority": "low",
        "dependencies": [
          9,
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement profiling infrastructure and benchmarks",
            "description": "Set up comprehensive profiling tools and create benchmark suites to measure current AST performance baseline for nodes, visitors, and transformations",
            "dependencies": [],
            "details": "Create benchmark harness in spec/benchmarks/ast_performance_spec.cr with tests for: node creation speed (1M nodes), visitor traversal performance, transformation overhead, memory allocation patterns. Use Crystal's built-in Benchmark module and memory profiler. Generate baseline metrics for comparison.",
            "status": "pending",
            "testStrategy": "Run benchmarks on various AST sizes (10, 100, 1K, 10K, 100K nodes), measure time and memory for each operation type, create performance regression tests with acceptable thresholds"
          },
          {
            "id": 2,
            "title": "Optimize leaf nodes with struct implementation",
            "description": "Convert appropriate leaf AST nodes from classes to structs for better memory efficiency and cache locality",
            "dependencies": [
              "11.1"
            ],
            "details": "Identify leaf nodes that are immutable and don't need inheritance (IntLit, FloatLit, StringLit, BoolLit, Identifier). Convert these to structs while maintaining Node interface compatibility. Implement hybrid approach where struct nodes are wrapped when polymorphism is needed. Profile memory savings and access speed improvements.",
            "status": "pending",
            "testStrategy": "Verify struct nodes maintain API compatibility, benchmark memory usage reduction (target 30-50% for literals), ensure no functionality regression, test struct/class interoperability"
          },
          {
            "id": 3,
            "title": "Implement node pooling for common literals",
            "description": "Create object pools for frequently used AST nodes like small integers, common identifiers, and boolean values to reduce allocation overhead",
            "dependencies": [
              "11.2"
            ],
            "details": "Implement thread-safe pools for: IntLit (-128 to 127), BoolLit (true/false singletons), common Identifier nodes (keywords, common variable names). Add pool statistics tracking and configurable pool sizes. Implement pool clearing for long-running processes. Consider weak references for automatic cleanup.",
            "status": "pending",
            "testStrategy": "Verify pooled nodes are properly shared, test thread safety with concurrent access, measure allocation reduction (target 70% for pooled values), test pool memory limits work correctly"
          },
          {
            "id": 4,
            "title": "Optimize visitor dispatch with jump tables",
            "description": "Replace dynamic dispatch in visitor pattern with optimized jump table implementation for faster traversal",
            "dependencies": [
              "11.1"
            ],
            "details": "Generate compile-time jump tables mapping node types to visitor methods. Implement type ID system for fast lookups. Create specialized visitors for common patterns (e.g., find nodes of type, collect all identifiers). Add visitor method inlining hints. Consider generating specialized visitors for hot paths identified by profiling.",
            "status": "pending",
            "testStrategy": "Benchmark visitor performance improvement (target 2-3x speedup), verify all node types dispatch correctly, test specialized visitors produce same results as generic ones, measure impact on binary size"
          },
          {
            "id": 5,
            "title": "Implement copy-on-write for AST transformations",
            "description": "Add efficient copy-on-write mechanism to minimize memory usage during AST transformations while maintaining immutability",
            "dependencies": [
              "11.3",
              "11.4"
            ],
            "details": "Implement smart node cloning that shares unchanged subtrees. Add reference counting or generation tracking to detect modifications. Create transformation API that automatically applies COW semantics. Optimize common transformation patterns (single node replacement, subtree substitution). Add debugging aids to track sharing effectiveness.",
            "status": "pending",
            "testStrategy": "Verify transformations produce correct results with COW, measure memory savings for partial tree modifications (target 80% reduction), test concurrent transformations work correctly, benchmark transformation speed remains acceptable"
          }
        ]
      },
      {
        "id": 12,
        "title": "Write comprehensive documentation and examples",
        "description": "Create full API documentation, tutorials, migration guides, and working examples demonstrating all features of the AST framework",
        "details": "Documentation deliverables:\n1. README.md with quick start guide\n2. API documentation for all public methods using Crystal doc comments\n3. Examples directory with:\n   - Simple expression language AST\n   - Type checker implementation\n   - Interpreter example\n   - AST optimizer/transformer\n   - Pretty printer usage\n4. Migration guide from manual AST\n5. Performance tuning guide\n6. Integration guide with hecate-parse\n7. Best practices for AST design\n8. Troubleshooting common issues\n\nUse Crystal's documentation generator and ensure all examples are tested in CI",
        "testStrategy": "Verify all examples compile and run correctly, ensure documentation generates without warnings, test that migration guide steps work, validate API docs are complete and accurate",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create README.md with quick start guide and API reference structure",
            "description": "Write the main README.md file with project overview, installation instructions, quick start examples, and structure for comprehensive API documentation",
            "dependencies": [],
            "details": "Create shards/hecate-ast/README.md with sections for: project description, installation via shard.yml, quick start example showing basic AST definition and usage, feature overview, links to detailed documentation, and basic troubleshooting. Include a simple but complete example that demonstrates defining an expression language AST with the DSL.",
            "status": "pending",
            "testStrategy": "Verify README examples compile and run correctly, ensure all code snippets are valid Crystal syntax, test that installation instructions work for a fresh project"
          },
          {
            "id": 2,
            "title": "Add Crystal doc comments to all public APIs and generate documentation",
            "description": "Document all public classes, modules, methods, and macros with comprehensive Crystal doc comments and configure documentation generation",
            "dependencies": [],
            "details": "Add detailed doc comments to: AST DSL macros (define, node, abstract), generated node classes and methods, visitor pattern classes and methods, utility modules (pretty printer, validator), and all public APIs. Include code examples in doc comments, parameter descriptions, return value documentation, and usage notes. Configure crystal docs generation in the justfile.",
            "status": "pending",
            "testStrategy": "Run crystal docs without warnings, verify all public APIs have documentation, check that doc examples compile, ensure generated HTML documentation is complete and navigable"
          },
          {
            "id": 3,
            "title": "Create example implementations demonstrating core AST features",
            "description": "Build working examples for expression language AST, type checker, interpreter, and AST transformer to showcase framework capabilities",
            "dependencies": [
              "12.1",
              "12.2"
            ],
            "details": "Create examples/ directory with: 1) Simple expression language (arithmetic, variables, functions) with lexer integration, 2) Type checker using visitor pattern for the expression language, 3) Tree-walking interpreter implementation, 4) AST optimizer that performs constant folding and dead code elimination, 5) Pretty printer showcasing formatting options. Each example should be self-contained with sample input files.",
            "status": "pending",
            "testStrategy": "Ensure all examples compile without errors, test each example with provided sample inputs, verify expected outputs match actual results, add examples to CI test matrix"
          },
          {
            "id": 4,
            "title": "Write migration guide and best practices documentation",
            "description": "Create comprehensive guides for migrating from manual AST implementations and establishing best practices for AST design",
            "dependencies": [
              "12.3"
            ],
            "details": "Write docs/migration_guide.md showing step-by-step process to convert manual AST classes to the DSL approach, with before/after code comparisons. Create docs/best_practices.md covering: when to use abstract nodes, field naming conventions, visitor vs direct traversal trade-offs, performance considerations, integration patterns with parsers, and common anti-patterns to avoid.",
            "status": "pending",
            "testStrategy": "Test migration steps with a sample manual AST, verify all best practice examples are valid, ensure code samples demonstrate the recommended approaches"
          },
          {
            "id": 5,
            "title": "Create integration guide and performance tuning documentation",
            "description": "Document how to integrate hecate-ast with hecate-parse and other components, plus performance optimization strategies",
            "dependencies": [
              "12.3",
              "12.4"
            ],
            "details": "Write docs/integration_guide.md showing: parser integration patterns, span preservation strategies, error recovery techniques, and REPL/incremental parsing support. Create docs/performance_guide.md covering: memory optimization for large ASTs, visitor pattern performance tips, caching strategies, profiling techniques, and benchmarking approaches. Include troubleshooting section for common issues like circular dependencies and memory leaks.",
            "status": "pending",
            "testStrategy": "Verify integration examples work with actual hecate-parse usage, test performance recommendations with benchmarks, ensure troubleshooting solutions resolve documented issues"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-07-12T21:43:14.427Z",
      "updated": "2025-07-26T02:28:03.925Z",
      "description": "Tasks for master context"
    }
  }
}